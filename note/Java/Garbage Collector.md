
>[!note]
>C, C++ 같은 언어에서는 사용자가 직접 메모리 할당과 해제를 컨트롤 해야 했습니다다.
>잦은 메모리 이슈가 까다로운 개발환경에서 벗어나기 위해 GC가 등장했습니다. 

---

`Garbage Collector (GC)`는 Java와 같은 프로그래밍 언어에서 메모리 관리를 자동으로 처리하는 시스템입니다. 개발자가 직접 메모리를 관리하지 않아도 되도록, 더 이상 필요하지 않은 객체들을 자동으로 메모리에서 해제해줍니다.

자바에서는 객체를 생성할 때, `힙 메모리`에 저장되는데, 이 객체가 더 이상 참조되지 않으면 GC가 해당 객체를 메모리에서 제거해줍니다. 이를 통해 메모리 누수를 방지하고, 성능을 최적화할 수 있습니다.

---

## Garbage Collection 동작 방식:

1. **Stop The World**: Stop The World는 가비지 컬렉션을 실행하기 위해 JVM이 **애플리케이션의 실행을 멈추는 작업**입니다. GC가 실행될 때는 GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업이 중단되고, GC가 완료되면 작업이 재개됩니다.
	- 당연히 모든 쓰레드가 작업이 중단되므로, GC의 성능 개선을 위해 튜닝을 한다면 GC 실행시간을 줄이는 작업을 하게 됩니다.

2. **Mark and Sweep**: 객체가 여전히 참조되고 있는지 확인하고, 참조되지 않는 객체를 '쓰레기'로 간주하여 삭제하는 방식입니다.
	- Mark : 사용되는 메모리와 사용되지 않는 메모리를 식별하는 작업
	- Sweep : Mark 단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업

3. **Generational Collection**: 자바의 GC는 메모리를 **세대별로** 나누어 관리합니다. 객체가 오래 살아남을수록 다른 영역으로 이동시키고, 그 영역에서 메모리 정리를 수행합니다. 일반적으로 두 개의 주요 영역이 있습니다:
    - **Young Generation**: 새로 생성된 객체가 저장되는 공간으로, 이곳의 객체들은 자주 GC의 대상이 됩니다.
	    - 해당 공간에서 발생하는 가비지 컬렉션을 `Minor GC`라고 합니다.
	    - Minor GC는 살아있는 객체를 찾아서 Old Generation으로 이동시키고, 사용되지 않는 객체는 제거합니다.
	    - Minor GC는 비교적 가볍고 빠르게 일어나는 반면, 수행 빈도가 높습니다.
    - **Old Generation**: Young Generation에서 살아남은 객체들이 이동하는 공간으로, 이곳에서는 상대적으로 덜 자주 GC가 발생합니다.
	    - 해당 공간에서 발생하는 가비지 컬렉션을 `Major GC`라고 합니다.
	    - Old Generation과 Young Generation을 모두 Collecting 하는 경우가 많아, Full GC라고도 부릅니다.
	    - Minor GC보다 덜 발생하지만, 그만큼 더 많은 리소스를 소모합니다. 그에 따라 애플리케이션이 잠시 중단될 수 있습니다.


---

## Minor GC와 Major GC

JVM의 Heap 영역은 처음 설계될 때 다음의 2가지를 전제로 설계되었습니다.

- 대부분의 객체는 금방 접근 불가능한(Unreachable) 상태가 된다.
- 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.

즉, 객체는 대부분 일회성이며, 메모리에 오랫동안 남아있는 경우는 드물다는 것입니다. 그렇기 때문에 **객체의 생존 기간**에 따라 물리적인 Heap 영역을 나누게 되었고 `Young, Old` 총 2가지 영역으로 설계되었습니다. 초기에는 Perm 영역이 존재했지만 Java 8 부터 제거되었습니다.

![Young, Old GC](https://velog.velcdn.com/images%2Fgkskaks1004%2Fpost%2Fb3e359e2-7254-4256-9246-fb63a24dc92b%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-07-17%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.52.40.png)

>[!important]
>Old 영역이 Young 영역보다 크게 할당되는 이유는 Young 영역의 수명이 짧은 객체들은 큰 공간을 필요로 하지 않으며 큰 객체들은 Young 영역이 아니라 바로 Old 영역에 할당되기 때문입니다.
>
>예외적인 상황으로 **Old 영역의 객체가 Young 영역의 객체를 참조하는 경우**도 존재할 것입니다. 이러한 경우를 대비해 Old 영역에는 512 bytes의 덩어리(Chunk)로 되어 있는 `카드 테이블(Card Table)`이 존재한다. 

>[!note]
>`카드 테이블`에는 Old 영역의 객체가 Young 영역의 객체를 참조할 때마다 그에 대한 정보가 표시된다. 카드 테이블이 도입된 이유는 간단하다. Young 영역에서 Minor GC가 실행될 때 **모든 Old 영역의 객체를 식별하는 것이 비효율적**이기 때문입니다.
>그렇기 때문에 Young 영역에서 가비지 컬렉션이 진행될 때 카드 테이블만 조회하여 GC의 대상인지 식별할 수 있도록 합니다.

---

### Minor GC의 동작 방식

Minor GC를 정확히 이해하기 위해서는 `Young 영역의 구조`에 대해 이해를 해야 합니다. Young 영역은 **1개의 Eden 영역과 2개의 Survival 영역, 총 3가지**로 나뉘어집니다.

- **Eden 영역**: 새로 생성된 객체가 할당(Allocation)되는 영역
- **Survival 영역**: 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역

객체가 새롭게 생성되면 Young 영역 중에서도 `Eden 영역`에 할당(Allocation)이 됩니다. 그리고 `Eden 영역`이 꽉 차면 `Minor GC`가 발생하게 되는데, **사용되지 않는 메모리는 해제되고** Eden 영역에 존재하는 객체는 (사용중인) `Survival 영역`으로 옮겨지게 된다. `Survival 영역`은 **총 2개이지만 반드시 1개의 영역에만 데이터가 존재해야 하는데**, Young 영역의 동작 순서를 자세히 살펴보도록 하자.

1. 새로 생성된 객체가 Eden 영역에 할당된다.

2. 객체가 계속 생성되어 Eden 영역이 꽉차게 되고 Minor GC가 실행된다.
    1. Eden 영역에서 사용되지 않는 객체의 메모리가 해제된다.
    2. Eden 영역에서 살아남은 객체는 1개의 Survivor 영역으로 이동된다.
    
3. 1~2번의 과정이 반복되다가 Survivor 영역이 가득 차게 되면 Survivor 영역의 살아남은 객체를 다른 Survivor 영역으로 이동시킨다.(**1개의 Survivor 영역은 반드시 빈 상태가 된다.**)

4. 이러한 과정을 반복하여 계속해서 살아남은 객체는 Old 영역으로 이동(Promotion)된다.

>[!note]
>객체의 생존 횟수를 카운트하기 위해 Minor GC에서 객체가 살아남은 횟수를 의미하는 age를 Object Header에 기록합니다. 그리고 Minor GC 때 Object Header에 기록된 age를 보고 **Old 영역으로의 Promotion 여부를 결정**합니다.

>[!warning]
>또한 Survivor 영역 중 1개는 반드시 사용이 되어야 한다. 만약 두 Survivor 영역에 모두 데이터가 존재하거나, 모두 사용량이 0이라면 현재 시스템이 정상적인 상황이 아님을 파악할 수 있다

> 가장 널리 사용되는 JVM 구현체인 Hotspot JVM에서는 Eden 영역에 객체를 빠르게 할당(Allocation)하기 위해 `bump the pointer`와 `TLABs(Thread-Local Allocation Buffers)`라는 기술을 사용하고 있습니다. 
> 
> - `bump the pointer`란 Eden 영역에 마지막으로 할당된 객체의 주소를 캐싱해두는 것입니다. `bump the pointer`를 통해 새로운 객체를 위해 유효한 메모리를 탐색할 필요 없이 **마지막 주소의 다음 주소**를 사용하게 함으로써 속도를 높이고 있습니다. 이를 통해 새로운 객체를 할당할 때 객체의 크기가 Eden 영역에 적합한지만 판별하면 되므로 빠르게 메모리 할당을 할 수 있습니다.
> 
> 싱글 쓰레드 환경이라면 문제가 없겠지만 **멀티쓰레드 환경**이라면 객체를 Eden 영역에 할당할 때 **락(Lock)을 걸어 동기화**를 해주어야 합니다. 멀티 쓰레드 환경에서의 성능 문제를 해결하기 위해 Hotspot JVM은 추가로 `TLABs(Thread-Local Allocation Buffers)`라는 기술을 도입하게 되었다.
> 
> - `TLABs(Thread-Local Allocation Buffers)`란 **각각의 쓰레드마다** Eden 영역에 *객체를 할당하기 위한 주소를 부여함으로써* **동기화 작업 없이** 빠르게 메모리를 할당하도록 하는 기술이다. 각각의 쓰레드는 자신이 갖는 주소에만 객체를 할당함으로써 동기화 없이 `bump the poitner`를 통해 빠르게 객체를 할당하도록 하고 있다.

![Minor GC, Major GC 동작 방식](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCyho2%2FbtqURvZRql6%2F4a7u6mMGofkpuURKQz0RT1%2Fimg.png)

### Major GC의 동작 방식

Young 영역에서 오래 살아남은 객체는 Old 영역으로 Promotion됨을 확인할 수 있었습니다. 그리고 Major GC는 객체들이 계속 Promotion되어 **Old 영역의 메모리가 부족해지면** 발생하게 됩니다. 
Young 영역은 일반적으로 Old 영역보다 크키가 작기 때문에 GC가 **보통 0.5초에서 1초 사이에** 끝납니다. 그렇기 때문에 Minor GC는 애플리케이션에 크게 영향을 주지 않습니다. 
하지만 Old 영역은 Young 영역보다 크며 **Young 영역을 참조할 수도 있습니다.** 그렇기 때문에 Major GC는 일반적으로 Minor GC보다 시간이 오래걸리며, **10배 이상의 시간**을 사용합니다.


---
## 자바에서 사용하는 대표적인 GC 알고리즘:

- **Serial GC**: 단일 스레드를 사용하여 GC를 수행합니다. 적은 메모리 환경에 적합합니다.
- **Parallel GC**: 여러 스레드를 사용해 GC를 병렬로 처리하여, 성능을 향상시킵니다.
- **G1 GC**: 최근 많이 사용되는 GC로, 짧은 응답 시간을 유지하면서 메모리를 효율적으로 관리하는 데 중점을 둡니다.
- **ZGC**: 자바 11에서 도입된 최신 GC로, 매우 짧은 GC 중단 시간과 큰 힙 메모리 관리를 지원합니다.

GC는 메모리 관리를 자동으로 처리해 주지만, GC가 동작하는 동안 애플리케이션의 일부가 일시적으로 중단될 수 있기 때문에, 성능에 민감한 애플리케이션에서는 이를 고려한 튜닝이 필요할 수 있습니다.

>[!note]
>이외에도 Pararrel Old GC, CMS(Concurrent Mark Sweep) GC 가 있습니다.

